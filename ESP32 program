#include <WiFi.h>
#include <FirebaseESP32.h>
#include <Wire.h>
#include <BH1750.h>
#include <ArduinoJson.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
//wifi config
const char* WIFI_SSID = "CAMPUS_WIFI";
const char* WIFI_PASSWORD = "WIFI_PASSWORD";
// Firebase Configuration
#define FIREBASE_HOST "your-project.firebaseio.com"
#define FIREBASE_AUTH "your-database-secret"
// Room Identification
const char* BUILDING = "building_1";
const char* ROOM = "room_203";
const char* DEVICE_ID = "esp32_smart_node_1";
// Hardware Pins
#define RELAY_LIGHT 2
#define RELAY_AC 3
#define RELAY_FAN 4
#define IR_BREAKBEAM_PIN 1
#define RADAR_RX_PIN 43
#define RADAR_TX_PIN 44
// Sensor Thresholds
#define LUX_THRESHOLD 200
#define RADAR_ENERGY_THRESHOLD 50
#define MOVEMENT_TIMEOUT 15000        // 15 seconds
#define DOOR_DEBOUNCE_TIME 300        // 300ms
#define OCCUPANCY_TIMEOUT 60000       // 1 minute
#define MAX_PEOPLE 20 //set by room

// objects
FirebaseData firebaseData;
FirebaseConfig config;
FirebaseAuth auth;
BH1750 lightSensor;
HardwareSerial radarSerial(1);
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org");

// data struct
struct RoomStatus {
  // Occupancy
  int peopleCount = 0;
  bool isOccupied = false;
  // Devices
  bool lightOn = false;
  bool acOn = false;
  bool fanOn = false;
  bool autoMode = true;
  // Environment
  float lightLevel = 0;
  unsigned long lastActivity = 0;
};

struct SensorData {
  float lux = 0;
  bool radarPresence = false;
  bool doorBeamBroken = false;
  int radarEnergyLevel = 0;
  unsigned long timestamp = 0;
};

struct OccupancyLogic {
  // State tracking
  bool pendingEntry = false;
  bool pendingExit = false;
  unsigned long entryStartTime = 0;
  unsigned long exitStartTime = 0;
  
  // Timing
  unsigned long lastMovementTime = 0;
  unsigned long lastDoorEventTime = 0;
  bool lastBeamState = false;
};

// variables
RoomStatus room;
SensorData sensors;
OccupancyLogic occupancy;

// Firebase paths
String basePath;
String controlPath;
String statusPath;
String sensorsPath;

// Timing
unsigned long lastFirebaseUpdate = 0;
unsigned long lastControlCheck = 0;
volatile bool doorEventTriggered = false;
volatile unsigned long lastIrTime = 0;

// System status
bool radarConnected = false;
bool firebaseConnected = false;

// ==================== INTERRUPT HANDLER ====================
void IRAM_ATTR doorSensorISR() {
  unsigned long currentTime = millis();
  if (currentTime - lastIrTime > DOOR_DEBOUNCE_TIME) {
    doorEventTriggered = true;
    lastIrTime = currentTime;
  }
}

// ==================== INITIALIZATION ====================
void initializeSystem() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n=== Smart Room Controller v3.0 ===");
  Serial.printf("Room: %s/%s | Device: %s\n", BUILDING, ROOM, DEVICE_ID);
  
  // Initialize Firebase paths
  basePath = String("/rooms/") + BUILDING + "/" + ROOM;
  controlPath = basePath + "/controls";
  statusPath = basePath + "/status";
  sensorsPath = basePath + "/sensors";
  
  initializeHardware();
  initializeWiFi();
  initializeFirebase();
  initializeTime();
  
  Serial.println("=== System Ready ===");
}

void initializeHardware() {
  Serial.println("Initializing hardware...");
  // Relays
  pinMode(RELAY_LIGHT, OUTPUT);
  pinMode(RELAY_AC, OUTPUT);
  pinMode(RELAY_FAN, OUTPUT);
  setAllRelays(false);
  // Light sensor
  Wire.begin(8, 9);
  if (lightSensor.begin(BH1750::CONTINUOUS_HIGH_RES_MODE)) {
    Serial.println("✓ Light sensor ready");
  } else {
    Serial.println("✗ Light sensor failed");
  }
  // Radar sensor
  initializeRadar();
  // IR sensor
  pinMode(IR_BREAKBEAM_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(IR_BREAKBEAM_PIN), doorSensorISR, CHANGE);
  Serial.println("✓ Hardware initialized");
}

void initializeRadar() {
  radarSerial.begin(256000, SERIAL_8N1, RADAR_RX_PIN, RADAR_TX_PIN);
  delay(200);
  // Enable radar
  uint8_t enableCmd[] = {0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01};
  radarSerial.write(enableCmd, sizeof(enableCmd));
  delay(100);
  radarConnected = true;
  Serial.println("✓ Radar initialized");
}

void initializeWiFi() {
  Serial.print("Connecting to WiFi");
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("\n✓ WiFi connected: %s\n", WiFi.localIP().toString().c_str());
  } else {
    Serial.println("\n✗ WiFi connection failed");
  }
}

void initializeFirebase() {
  if (WiFi.status() != WL_CONNECTED) return;
  
  config.host = FIREBASE_HOST;
  config.signer.tokens.legacy_token = FIREBASE_AUTH;
  
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  
  // Test connection
  if (Firebase.ready()) {
    firebaseConnected = true;
    Serial.println("✓ Firebase connected");
    
    // Initialize device status in Firebase
    updateFirebaseStatus();
  } else {
    Serial.println("✗ Firebase connection failed");
  }
}

void initializeTime() {
  timeClient.begin();
  timeClient.setTimeOffset(28800); // GMT+8 for Malaysia
  Serial.println("✓ Time client initialized");
}

// ==================== SENSOR READING ====================
void readAllSensors() {
  sensors.timestamp = millis();
  
  // Light sensor
  sensors.lux = lightSensor.readLightLevel();
  if (sensors.lux < 0) sensors.lux = 0;
  room.lightLevel = sensors.lux;
  
  // Radar sensor
  readRadarSensor();
  
  // Door beam sensor
  sensors.doorBeamBroken = (digitalRead(IR_BREAKBEAM_PIN) == LOW);
}

void readRadarSensor() {
  static unsigned long lastRadarRead = 0;
  
  if (!radarConnected || (millis() - lastRadarRead < 100)) return;
  lastRadarRead = millis();
  
  sensors.radarEnergyLevel = 0;
  sensors.radarPresence = false;
  
  int bytesAvailable = radarSerial.available();
  if (bytesAvailable > 10) {
    uint8_t buffer[64];
    int bytesRead = min(bytesAvailable, 64);
    
    // Read data
    for (int i = 0; i < bytesRead && radarSerial.available(); i++) {
      buffer[i] = radarSerial.read();
    }
    
    // Parse radar data
    parseRadarData(buffer, bytesRead);
  }
}

void parseRadarData(uint8_t* buffer, int length) {
  for (int i = 0; i < length - 8; i++) {
    // Look for data frame header
    if (buffer[i] == 0xF4 && buffer[i+1] == 0xF3 && 
        buffer[i+2] == 0xF2 && buffer[i+3] == 0xF1) {
      
      int energyValue = (buffer[i+6] << 8) | buffer[i+5];
      sensors.radarEnergyLevel = max(sensors.radarEnergyLevel, energyValue);
      
      if (energyValue > RADAR_ENERGY_THRESHOLD) {
        sensors.radarPresence = true;
      }
      break;
    }
  }
  
  // Fallback: detect presence by serial activity
  if (!sensors.radarPresence && radarSerial.available() > 20) {
    sensors.radarPresence = true;
    sensors.radarEnergyLevel = 100;
  }
}

// ==================== OCCUPANCY DETECTION ====================
void processOccupancyDetection() {
  unsigned long currentTime = millis();
  
  // Handle door events
  if (doorEventTriggered) {
    handleDoorEvent(currentTime);
    doorEventTriggered = false;
  }
  
  // Update movement tracking
  if (sensors.radarPresence) {
    occupancy.lastMovementTime = currentTime;
    room.lastActivity = currentTime;
  }
  
  // Process door crossing logic
  updateDoorCrossingLogic(currentTime);
  
  // Handle occupancy timeout
  handleOccupancyTimeout(currentTime);
  
  // Update room status
  room.isOccupied = (room.peopleCount > 0) || 
                   (currentTime - occupancy.lastMovementTime < MOVEMENT_TIMEOUT);
}

void handleDoorEvent(unsigned long currentTime) {
  occupancy.lastDoorEventTime = currentTime;
  occupancy.lastBeamState = sensors.doorBeamBroken;
  
  Serial.printf("Door: %s | Radar: %s (Energy: %d)\n",
                sensors.doorBeamBroken ? "BLOCKED" : "CLEAR",
                sensors.radarPresence ? "DETECTED" : "NONE",
                sensors.radarEnergyLevel);
}

void updateDoorCrossingLogic(unsigned long currentTime) {
  // Start entry/exit detection
  if (sensors.doorBeamBroken && sensors.radarPresence && 
      !occupancy.pendingEntry && !occupancy.pendingExit) {
    
    if (shouldTriggerEntry()) {
      startEntrySequence(currentTime);
    } else {
      startExitSequence(currentTime);
    }
  }
  
  // Complete entry
  if (occupancy.pendingEntry && !sensors.doorBeamBroken) {
    if (isValidCrossingDuration(currentTime - occupancy.entryStartTime)) {
      completeEntry();
    }
    occupancy.pendingEntry = false;
  }
  
  // Complete exit
  if (occupancy.pendingExit && !sensors.doorBeamBroken) {
    if (isValidCrossingDuration(currentTime - occupancy.exitStartTime)) {
      completeExit();
    }
    occupancy.pendingExit = false;
  }
  
  // Clear stuck states
  clearStuckStates(currentTime);
}

bool shouldTriggerEntry() {
  // Entry more likely if room is empty or strong radar signal
  return (room.peopleCount == 0) || 
         (sensors.radarEnergyLevel > RADAR_ENERGY_THRESHOLD * 1.5);
}

void startEntrySequence(unsigned long currentTime) {
  occupancy.pendingEntry = true;
  occupancy.entryStartTime = currentTime;
  Serial.println("→ Entry sequence started");
}

void startExitSequence(unsigned long currentTime) {
  occupancy.pendingExit = true;
  occupancy.exitStartTime = currentTime;
  Serial.println("← Exit sequence started");
}

bool isValidCrossingDuration(unsigned long duration) {
  return (duration > DOOR_DEBOUNCE_TIME && duration < 3000);
}

void completeEntry() {
  room.peopleCount = min(room.peopleCount + 1, MAX_PEOPLE);
  occupancy.lastMovementTime = millis();
  Serial.printf("✓ Entry confirmed - Count: %d\n", room.peopleCount);
}

void completeExit() {
  room.peopleCount = max(room.peopleCount - 1, 0);
  Serial.printf("✓ Exit confirmed - Count: %d\n", room.peopleCount);
}

void clearStuckStates(unsigned long currentTime) {
  const unsigned long STUCK_TIMEOUT = 5000;
  
  if (occupancy.pendingEntry && 
      (currentTime - occupancy.entryStartTime > STUCK_TIMEOUT)) {
    occupancy.pendingEntry = false;
    Serial.println("Entry timeout cleared");
  }
  
  if (occupancy.pendingExit && 
      (currentTime - occupancy.exitStartTime > STUCK_TIMEOUT)) {
    occupancy.pendingExit = false;
    Serial.println("Exit timeout cleared");
  }
}

void handleOccupancyTimeout(unsigned long currentTime) {
  if (room.peopleCount > 0 && 
      (currentTime - occupancy.lastMovementTime > OCCUPANCY_TIMEOUT)) {
    Serial.println("⚠ Occupancy timeout - clearing room");
    room.peopleCount = 0;
    room.isOccupied = false;
  }
}

// ==================== AUTOMATION CONTROL ====================
void applyAutomationLogic() {
  if (!room.autoMode) return;
  
  controlLighting();
  controlFan();
  controlAirConditioning();
}

void controlLighting() {
  static unsigned long lightOffDelay = 0;
  bool shouldBeOn = room.isOccupied && (sensors.lux < LUX_THRESHOLD);
  
  if (shouldBeOn && !room.lightOn) {
    setLight(true);
    lightOffDelay = 0;
    Serial.println("Auto: Light ON");
  } 
  else if (!shouldBeOn && room.lightOn) {
    // Delayed turn off to prevent flickering
    if (lightOffDelay == 0) {
      lightOffDelay = millis();
    } else if (millis() - lightOffDelay > 10000) {
      setLight(false);
      lightOffDelay = 0;
      Serial.println("Auto: Light OFF");
    }
  } 
  else if (shouldBeOn) {
    lightOffDelay = 0; // Cancel delayed off
  }
}

void controlFan() {
  bool shouldBeOn = room.isOccupied;
  
  if (shouldBeOn != room.fanOn) {
    setFan(shouldBeOn);
    Serial.printf("Auto: Fan %s\n", shouldBeOn ? "ON" : "OFF");
  }
}

void controlAirConditioning() {
  bool shouldBeOn = (room.peopleCount >= 3); // AC for 3+ people
  
  if (shouldBeOn != room.acOn) {
    setAC(shouldBeOn);
    Serial.printf("Auto: AC %s (Count: %d)\n", 
                  shouldBeOn ? "ON" : "OFF", room.peopleCount);
  }
}

// ==================== DEVICE CONTROL ====================
void setLight(bool state) {
  room.lightOn = state;
  digitalWrite(RELAY_LIGHT, state ? HIGH : LOW);
}

void setFan(bool state) {
  room.fanOn = state;
  digitalWrite(RELAY_FAN, state ? HIGH : LOW);
}

void setAC(bool state) {
  room.acOn = state;
  digitalWrite(RELAY_AC, state ? HIGH : LOW);
}

void setAllRelays(bool state) {
  setLight(state);
  setFan(state);
  setAC(state);
}

// ==================== FIREBASE COMMUNICATION ====================
void updateFirebase() {
  if (!firebaseConnected || !Firebase.ready()) return;
  
  unsigned long currentTime = millis();
  if (currentTime - lastFirebaseUpdate < 5000) return; // Limit updates
  
  updateFirebaseSensors();
  updateFirebaseStatus();
  
  lastFirebaseUpdate = currentTime;
}

void updateFirebaseSensors() {
  timeClient.update();
  
  // Create JSON object for sensor data
  FirebaseJson sensorJson;
  sensorJson.set("timestamp", timeClient.getEpochTime());
  sensorJson.set("lux", sensors.lux);
  sensorJson.set("peopleCount", room.peopleCount);
  sensorJson.set("isOccupied", room.isOccupied);
  sensorJson.set("radarPresence", sensors.radarPresence);
  sensorJson.set("radarEnergy", sensors.radarEnergyLevel);
  sensorJson.set("doorBlocked", sensors.doorBeamBroken);
  
  // Push to Firebase with timestamp-based key
  String path = sensorsPath + "/data_" + String(timeClient.getEpochTime());
  
  if (Firebase.setJSON(firebaseData, path.c_str(), sensorJson)) {
    // Success - sensor data pushed
  } else {
    Serial.println("Firebase sensor update failed: " + firebaseData.errorReason());
  }
}

void updateFirebaseStatus() {
  // Create JSON object for device status
  FirebaseJson statusJson;
  statusJson.set("deviceId", DEVICE_ID);
  statusJson.set("autoMode", room.autoMode);
  statusJson.set("lightOn", room.lightOn);
  statusJson.set("acOn", room.acOn);
  statusJson.set("fanOn", room.fanOn);
  statusJson.set("wifiConnected", WiFi.status() == WL_CONNECTED);
  statusJson.set("wifiRSSI", WiFi.RSSI());
  statusJson.set("freeHeap", ESP.getFreeHeap());
  statusJson.set("uptime", millis() / 1000);
  statusJson.set("lastUpdate", timeClient.getEpochTime());
  
  if (Firebase.setJSON(firebaseData, statusPath.c_str(), statusJson)) {
    // Success - status updated
  } else {
    Serial.println("Firebase status update failed: " + firebaseData.errorReason());
  }
}

void checkFirebaseControls() {
  if (!firebaseConnected || !Firebase.ready()) return;
  
  unsigned long currentTime = millis();
  if (currentTime - lastControlCheck < 2000) return; // Check every 2 seconds
  
  // Get control data from Firebase
  if (Firebase.getJSON(firebaseData, controlPath.c_str())) {
    FirebaseJson &json = firebaseData.jsonObject();
    FirebaseJsonData jsonData;
    
    // Check light control
    if (json.get(jsonData, "light") && jsonData.success) {
      bool lightState = jsonData.boolValue;
      if (lightState != room.lightOn) {
        setLight(lightState);
        room.autoMode = false; // Disable auto mode on manual control
        Serial.printf("Remote: Light %s\n", lightState ? "ON" : "OFF");
      }
    }
    
    // Check fan control
    if (json.get(jsonData, "fan") && jsonData.success) {
      bool fanState = jsonData.boolValue;
      if (fanState != room.fanOn) {
        setFan(fanState);
        room.autoMode = false;
        Serial.printf("Remote: Fan %s\n", fanState ? "ON" : "OFF");
      }
    }
    
    // Check AC control
    if (json.get(jsonData, "ac") && jsonData.success) {
      bool acState = jsonData.boolValue;
      if (acState != room.acOn) {
        setAC(acState);
        room.autoMode = false;
        Serial.printf("Remote: AC %s\n", acState ? "ON" : "OFF");
      }
    }
    
    // Check auto mode
    if (json.get(jsonData, "autoMode") && jsonData.success) {
      bool autoState = jsonData.boolValue;
      if (autoState != room.autoMode) {
        room.autoMode = autoState;
        Serial.printf("Remote: Auto mode %s\n", autoState ? "ON" : "OFF");
      }
    }
  } else {
    // Control data not available or error
  }
  
  lastControlCheck = currentTime;
}


void setup() {
  initializeSystem();
}

void loop() {
  // Read sensors
  readAllSensors();
  
  // Process occupancy detection
  processOccupancyDetection();
  
  // Apply automation
  applyAutomationLogic();
  
  // Update Firebase
  updateFirebase();
  
  // Check for remote controls
  checkFirebaseControls();
  
  // Debug output
  static unsigned long lastDebug = 0;
  if (millis() - lastDebug > 10000) {
    Serial.printf("Status - Count: %d | Occupied: %s | Lux: %.1f | Radar: %s\n",
                  room.peopleCount, room.isOccupied ? "Yes" : "No",
                  sensors.lux, sensors.radarPresence ? "Yes" : "No");
    lastDebug = millis();
  }
  
  delay(50); // Prevent watchdog timeout
}
